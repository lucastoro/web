<!DOCTYPE html>
<html>
    <head>
        <style>
            html, body {
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
                overflow: hidden;
                background-color: #111;
                color: #fff;
                font-family: monospace;
                font-size: 12px;
            }
            canvas {
                width: 100%;
                height: 100%;
            }
            #report {
                position: fixed;
                top: 0;
                left: 0;
                margin: 0;
                padding: 8px;
            }
        </style>
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <pre id="report"></pre>
        <script>
            const report = document.getElementById('report');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');



            const Point = Vector2D;

            class Island {
                constructor(a, b) {
                    this.a = a;
                    this.b = b;
                }
            }

            function distance(a, b) {
                return Math.sqrt(
                    Math.pow(a.x - b.x, 2) +
                    Math.pow(a.y - b.y, 2)
                );
            }

            function solve1(map) {

                // minimize the length of the segments [O(N)]

                let result = [map.start];

                let last = map.start;

                for (let i = 0; i < map.islands.length; ++i) {
                    const a = distance(last, map.islands[i].a);
                    const b = distance(last, map.islands[i].b);
                    if (a < b) {
                        last = map.islands[i].a;
                        result.push(last);
                    }
                    else {
                        last = map.islands[i].b;
                        result.push(last);
                    }
                }

                result.push(map.end);
                return result;
            }

            function optimize(path) {

                // skips local minima [O(N)]

                const optimal = lineFrom2Points(path[0], path[path.length - 1]);
                const result = [path[0]];

                function isAbove(p) {
                    const perp = perpendicular(optimal, p);
                    const proj = intercept(optimal, perp);
                    return proj.y >= p.y;
                }

                function canSkip(a, b, c) {

                    const maybe = lineFrom2Points(a, c);
                    const perp = perpendicular(optimal, b);
                    const inter = intercept(maybe, perp);

                    if (isAbove(b)) {
                        return (inter.y < b.y)
                    }

                    return (inter.y > b.y)
                }

                for (let i = 0; i < path.length - 2; ++i) {

                    const a = path[i];

                    while (i < path.length - 2) { // this might seem like a O(NN) or O(NM) but it still iterates over i, it's O(N)

                        const b = path[i + 1];
                        const c = path[i + 2];

                        if (canSkip(a, b, c)) {
                            console.debug(`skipping ${i + 1}/${path.length - 2}`);
                            ++i;
                        } else {
                            result.push(b);
                            break;
                        }
                    }
                }

                result.push(path[path.length - 1]);

                return result;
            }

            function total_length(path) {

                let tot = 0;

                for (let i = 1; i < path.length; ++i) {
                    tot += distance(path[i - 1], path[i]);
                }

                return tot;
            }

            const FOREGROUND_COLOR = 'white';

            function drawPoint(ctx, point, options) {

                options = options ?? {};
                options.radius = options.radius ?? 5;

                if (!options.stroke && !options.fill) {
                    options.stroke = FOREGROUND_COLOR;
                }

                ctx.beginPath();
                ctx.ellipse(point.x, point.y, options.radius, options.radius, 0, 0, 2 * Math.PI);

                if (options.fill) {
                    ctx.fillStyle = options.fill;
                    ctx.fill();
                }

                if (options.stroke) {
                    ctx.strokeStyle = options.stroke;
                    ctx.stroke();
                }
            }

            function drawIsland(ctx, island, options) {

                const x = (island.a.x + island.b.x) / 2;
                const y = (island.a.y + island.b.y) / 2;
                const d = distance(island.a, island.b);

                drawPoint(ctx, new Point(x, y), {radius: d / 2});
                drawPoint(ctx, island.a, {radius: 5});
                drawPoint(ctx, island.b, {radius: 5});
            }

            function drawLineBetween(ctx, a, b, options) {

                options = options ?? {};
                options.color = options.color ?? FOREGROUND_COLOR;

                if (options.dash) {
                    ctx.setLineDash(options.dash);
                }

                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.strokeStyle = options.color;
                ctx.stroke();

                if (options.dash) {
                    ctx.setLineDash([]);
                }
            }

            function drawLine(ctx, line, options) {
                const a = new Point(0, line.m * 0 + line.c);
                const b = new Point(window.innerWidth, line.m * window.innerWidth + line.c);
                drawLineBetween(ctx, a, b, options);
            }

            function drawMap(ctx, map) {
                drawPoint(ctx, map.start, {radius: 5, fill: 'green'});
                drawPoint(ctx, map.end, {radius: 5, fill: 'blue'});
                drawLineBetween(ctx, map.start, map.end, {dash: [2, 8]});

                map.islands.forEach(island => {
                    drawIsland(ctx, island);
                });
            }

            function drawPath(ctx, path, options) {

                options = options ?? {};
                options.color = options.color ?? FOREGROUND_COLOR;

                if (options.dash) {
                    if (options.dash instanceof Array)
                        ctx.setLineDash(options.dash);
                    else
                        ctx.setLineDash([options.dash]);
                }

                if (options.size) {
                    ctx.lineWidth = options.size;
                }

                ctx.strokeStyle = options.color;
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);

                for (let i = 1; i < path.length; ++i) {
                    ctx.lineTo(path[i].x, path[i].y);
                }

                ctx.stroke();

                if (options.dash) {
                    ctx.setLineDash([]);
                }

                if (options.size) {
                    ctx.lineWidth = null;
                }
            }

            function buildMap() {

                const minR = 10;
                const maxR = 50;
                const minC = 3;
                const maxC = 10;

                const start = new Point(100, window.innerHeight / 2);
                const end   = new Point(window.innerWidth - 100, 100 + Math.random() * (window.innerHeight - 200));
                const islands = [];

                const count = Math.round(minC + Math.random() * (maxC - minC));
                const line = lineFrom2Points(start, end);

                for (let i = 0; i < count; ++i) {

                    const x = start.x + 100 + i * ((end.x - start.x - 100) / count) + (Math.random() * 100 * (Math.random() * 2 - 1)); // start.x + Math.random() * (end.x - start.x);
                    const y = line.m * x + line.c;
                    const center = new Point(x, y);
                    const r = minR + Math.random() * (maxR - minR);
                    const perp = perpendicular(line, center);
                    const k = Math.random() * (r * 0.9) * (Math.random() * 2 - 1);
                    const a = intercept(perp, new Line(line.m, line.c + r + k));
                    const b = intercept(perp, new Line(line.m, line.c - r + k));

                    islands.push(new Island(a, b));
                }

                islands.sort((a, b) => a.a.x - b.a.x );

                return {start, end, islands};
            }

            // const map = buildMap();
            const map = {
                "start": new Point(100, 281),
                "end":   new Point(1024, 333.6275121076801),
                "islands": [
                    new Island(new Point(194.728673381117, 304.40563857488223), new Point(197.2410778378714, 260.2944574631638)),
                    new Island(new Point(283.7817777539803, 334.58650480281904), new Point(288.5484861170472, 250.89570599663512)),
                    new Island(new Point(420.2890146550559, 319.9743352592677), new Point(422.614593059051, 279.1433257885028)),
                    new Island(new Point(515.879304000056, 347.6322253221024), new Point(520.7785047774987, 261.61520994248895)),
                    new Island(new Point(614.7707618309576, 380.37403046577856), new Point(620.1487908896282, 285.95005617559764)),
                    new Island(new Point(749.5855826229883, 344.4889037293324), new Point(752.2501969666968, 297.7053193457705)),
                    new Island(new Point(780.6981967610951, 333.9743398495848), new Point(782.9780982877392, 293.94529560541196)),
                    new Island(new Point(945.0703223478464, 356.9156622507471), new Point(948.2542224918097, 301.0147918656403))
                ]
            };

            function normalize(map) {

                const x = lineFrom2Points(map.start, map.end);
                const a = Math.atan(x.m);
                const mat = new Matrix2D().rotate(a);

                map.start = mat.multiply(map.start);
                map.end = mat.multiply(map.end);

                for (let i = 0; i < map.islands.length; ++i) {
                    map.islands[i].a = mat.multiply(map.islands[i].a);
                    map.islands[i].b = mat.multiply(map.islands[i].b);
                }
            }

            function brute(map) {

                function expand(node, index) {

                    if (index == node.length - 1) {
                        console.assert(node[index] instanceof Point);
                        return [[node[index]]];
                    }

                    const next = expand(node, index + 1);
                    const result = [];
                    const self = node[index];
                    next.forEach(n => {
                        if (self instanceof Point) {
                            result.push([self, ...n]);
                        }
                        else {
                            result.push([self.a, ...n]);
                            result.push([self.b, ...n]);
                        }
                    });

                    return result;
                }

                const flat = [map.start, ...map.islands, map.end];
                const all_paths = expand(flat, 0).map(path => optimize(path));
                const wightened = all_paths.map(path => [path, total_length(path)]);
                wightened.sort((a, b) => a[1] - b[1]);
                return wightened[0][0];
            }

            function describe(map) {
                return `{
    "start": new Point(${map.start.x}, ${map.start.y}),
    "end":   new Point(${map.end.x}, ${map.end.y}),
    "islands": [
        ${map.islands.map(i => `new Island(new Point(${i.a.x}, ${i.a.y}), new Point(${i.b.x}, ${i.b.y}))`).join(',\n        ')}
    ]
}`;
            }

            const path1 = solve1(map);
            const path2 = optimize(path1);
            const path3 = brute(map);

            const c1 = total_length(path1);
            const c2 = total_length(path2);
            const c3 = total_length(path3);

            let text = 'Results:\n' +
            `min segment [orange] = ${c1}\n` +
            `optimized   [ red  ] = ${c2}\n` +
            `brute force [green ] = ${c3}\n`;

            if (c3 < c2) {
                text += 'WARNING! Suboptimal route found!\n';
                text += `Brute forced path is ${c2 - c3} pixel shorter!\n`;
                text += 'Check the logs for the map desciption';
                console.log(describe(map));
            }

            report.innerText = text;

            function draw() {
                drawMap(ctx, map);
                drawPath(ctx, path1, {color: 'orange', dash: [5, 3]});
                drawPath(ctx, path2, {color: 'red'});
                drawPath(ctx, path3, {color: 'green'});
            }

            function onResize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                draw();
            }

            window.addEventListener('resize', onResize);

            onResize();

        </script>
    </body>
</html>